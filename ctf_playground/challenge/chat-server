#!/usr/bin/env python

import functools
import hashlib
import os
import sqlite3
import textwrap

from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from flask import Flask, request, session, redirect


HOST = os.getenv("CHAT_HOST", "127.0.0.1")
PORT = int(os.getenv("CHAT_PORT", 8080))
DB_PATH = os.getenv("DB_PATH", "./chat.db")


app = Flask(__name__)


def initialize_db():
    db = sqlite3.connect(DB_PATH)
    db.execute("CREATE TABLE IF NOT EXISTS users (username TEXT, hashed_password TEXT, admin BOOLEAN)")
    db.execute("CREATE TABLE IF NOT EXISTS encrypted_chats (encrypted_username_1 TEXT, encrypted_username_2 TEXT, encrypted_contents TEXT)")
    return db

db = initialize_db()


def encrypt(data, key=None):
    cipher = AES.new(app.secret_key, AES.MODE_ECB)
    return cipher.encrypt(pad(data, cipher.block_size))


def decrypt(data, key=None):
    cipher = AES.new(app.secret_key, AES.MODE_ECB)
    try:
        return unpad(cipher.decrypt(data), cipher.block_size)
    except ValueError:
        raise RuntimeError("Invalid padding")


def authed_only(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        if "username" not in session:
            return "You are not logged in! Please <a href='/login'>login</a> or <a href='/register'>register</a>.", 403
        return func(*args, **kwargs)
    return wrapper


@app.after_request
def format_response(response):
    if response.content_type.startswith("text/html"):
        original_data = response.get_data(as_text=True)
        dedented_data = textwrap.dedent(original_data).strip() + "\n"
        response.set_data(dedented_data)
    return response


@app.route("/")
def index():
    if "username" not in session:
        return 'Hello! Please <a href="/login">login</a> or <a href="/register">register</a>.'
    return f"""Hello {session['username']}! You are {'an admin' if session.get('admin   ') else 'not an admin'}.
    <br>
    <form action="/chat" method="get">
        <input type="text" name="other_username" placeholder="Username" required>
        <input type="submit" value="Chat">
    </form>
    """


@app.route("/register", methods=["GET", "POST"])
def register():
    if request.method == "GET":
        return """
        <form method="post">
            <input type="text" name="username" placeholder="Username" required>
            <input type="password" name="password" placeholder="Password" required>
            <input type="submit" value="Register">
        </form>
        """
    try:
        username = request.form["username"]
        password = request.form["password"]
    except KeyError:
        return "Missing username or password. Back to <a href='/'>home</a>.", 400
    if db.execute(f"SELECT * FROM users WHERE username='{username}'").fetchone():
        return "Username already exists. Back to <a href='/'>home</a>.", 400
    hashed_password = hashlib.sha256(password.encode()).hexdigest()
    admin = request.remote_addr == "127.0.0.1"
    db.execute(f"INSERT INTO users VALUES ('{username}', '{hashed_password}', {'true' if admin else 'false'})")
    db.commit()
    session["username"] = username
    session["admin"] = admin
    return redirect("/")


@app.route("/login", methods=["GET", "POST"])
def login():
    if request.method == "GET":
        return """
        <form method="post">
            <input type="text" name="username" placeholder="Username" required>
            <input type="password" name="password" placeholder="Password" required>
            <input type="submit" value="Login">
        </form>
        """
    try:
        username = request.form["username"]
        password = request.form["password"]
    except KeyError:
        return "Missing username or password. Back to <a href='/'>home</a>.", 400
    hashed_password = hashlib.sha256(password.encode()).hexdigest()
    result =  db.execute(f"SELECT * FROM users WHERE username='{username}' and hashed_password='{hashed_password}'").fetchone()
    if not result:
        return "Invalid username or password. Back to <a href='/'>home</a>.", 400
    username, _, admin = result

    if admin and request.remote_addr != "127.0.0.1":
        return "Admins may only login locally. Back to <a href='/'>home</a>.", 403

    session["username"] = username
    session["admin"] = admin
    return redirect("/")


@app.route("/chat/", methods=["GET"])
@app.route("/chat/<other_username>", methods=["HEAD", "GET", "POST"])
@authed_only
def chat(other_username=None):
    if request.args.get("other_username"):
        return redirect(f"/chat/{request.args['other_username']}")

    username = session["username"]

    result = db.execute(f"SELECT * FROM users WHERE username='{other_username}'").fetchone()
    if not result:
        return "User does not exist. Back to <a href='/'>home</a>.", 404

    encrypted_username_1, encrypted_username_2 = sorted([encrypt(username.encode()).hex(), encrypt(other_username.encode()).hex()])
    result = db.execute(f"SELECT encrypted_contents FROM encrypted_chats WHERE encrypted_username_1='{encrypted_username_1}' AND encrypted_username_2='{encrypted_username_2}'").fetchone()
    try:
        contents = decrypt(bytes.fromhex(result[0])).decode() if result else ""
    except RuntimeError:
        # Failed to correctly decrypt, web server restarted (and generated a new secret key) or it was tampered with
        # Delete the chat and start a new one
        contents = ""

    etag = hashlib.sha256(contents.encode()).hexdigest()

    if request.method == "HEAD":
        return "", 200, {"ETag": etag}

    if request.method == "GET":
        contents_html = "\n<br>\n".join(contents.splitlines())
        return f"""
            <main>
            {contents_html}
            </main>
            <form method="post">
                <input id="message" type="text" name="message" placeholder="Message" required>
                <input type="submit" value="Send">
            </form>
            <script>
                let etag = "{etag}";
                window.scrollTo(0, document.body.scrollHeight);
                message.value = localStorage.getItem("message") || "";
                localStorage.removeItem("message");
                message.focus();
                interval = setInterval(() => {{
                    fetch(location.href, {{method: "HEAD"}}).then(response => {{
                        if (response.headers.get("ETag") !== etag) {{
                            localStorage.setItem("message", message.value);
                            location.reload();
                        }}
                    }});
                }}, 5000);
            </script>
        """, 200, {"ETag": etag}

    if request.method == "POST":
        try:
            message = request.form["message"].strip().replace("\n", " ")
        except KeyError:
            return "Missing message. Back to <a href='/'>home</a>.", 400
        encrypted_contents = encrypt((contents + f"{username}: {message}\n").encode()).hex()
        if contents:
            db.execute(f"UPDATE encrypted_chats SET encrypted_contents='{encrypted_contents}' WHERE encrypted_username_1='{encrypted_username_1}' AND encrypted_username_2='{encrypted_username_2}'")
        else:
            db.execute(f"INSERT INTO encrypted_chats VALUES ('{encrypted_username_1}', '{encrypted_username_2}', '{encrypted_contents}')")
        db.commit()
        return redirect(f"/chat/{other_username}")


@app.route("/user/modify", methods=["GET"])
@app.route("/user/<username>/modify", methods=["GET", "POST"])
@authed_only
def modify_user(username=None):
    if username is None:
        return redirect(f"/user/{session['username']}/modify")

    result = db.execute(f"SELECT * FROM users WHERE username='{username}'").fetchone()
    if not result:
        return "User does not exist. Back to <a href='/'>home</a>.", 400
    username, password, admin = result
    admin = bool(admin)

    if request.method == "GET" and session["admin"]:
        return f"""
        Modify user {username}:
        <form method="post">
            <input type="text" name="username" placeholder="Username" value="{username}">
            <input type="password" name="password" placeholder="Password">
            <input type="checkbox" name="admin" value="{'true' if admin else 'false'}"> Admin
            <input type="submit" value="Modify">
            <input type="submit" name="delete" value="Delete User">
        </form>
        """
    elif request.method == "GET" and not session["admin"]:
        return f"""
        Modify user {username}:
        <form method="post">
            <input type="password" name="password" placeholder="Password">
            <input type="submit" value="Modify">
            <input type="submit" name="delete" value="Delete">
        </form>
        """

    new_username = request.form.get("username", username)
    new_password = hashlib.sha256(request.form["password"].encode()).hexdigest() if request.form.get("password") else password
    new_admin = request.form.get("admin", ("true" if admin else "false")) == "true"

    admin_only = not all((username == new_username == session["username"],
                          admin == new_admin == session["admin"]))

    if admin_only and not session.get("admin"):
        return "You must be an admin to modify other users. Back to <a href='/'>home</a>.", 403

    encrypted_username = encrypt(username.encode()).hex()

    if "delete" in request.form:
        db.execute(f"DELETE FROM users WHERE username='{username}'")
        db.execute(f"UPDATE encrypted_chats SET encrypted_username_1=NULL WHERE encrypted_username_1='{encrypted_username}'")
        db.execute(f"UPDATE encrypted_chats SET encrypted_username_2=NULL WHERE encrypted_username_2='{encrypted_username}'")
        db.execute(f"DELETE FROM encrypted_chats WHERE encrypted_username_1 IS NULL AND encrypted_username_2 IS NULL")
        db.commit()
        if session["username"] == username:
            session.clear()
        return "User deleted. Back to <a href='/'>home</a>."

    db.execute(f"UPDATE users SET username='{new_username}', hashed_password='{new_password}', admin={'true' if new_admin else 'false'} WHERE username='{username}'")

    if new_username != username:
        encrypted_username = encrypt(username.encode()).hex()
        encrypted_new_username = encrypt(new_username.encode()).hex()
        result = db.execute(f"SELECT * FROM encrypted_chats WHERE encrypted_username_1='{encrypted_username}' OR encrypted_username_2='{encrypted_username}'").fetchall()
        for encrypted_username_1, encrypted_username_2, encrypted_contents in result:
            contents = decrypt(bytes.fromhex(encrypted_contents)).decode()
            new_encrypted_username_1, new_encrypted_username_2 = sorted([encrypted_new_username if encrypted_username_1 == encrypted_username else encrypted_username_1,
                                                                         encrypted_new_username if encrypted_username_2 == encrypted_username else encrypted_username_2],
                                                                        key=lambda k: k or "")
            new_encrypted_contents = encrypt("".join(
                (line.replace(f"{username}: ", f"{new_username}: ", 1) if line.startswith(f"{username}: ") else line) + "\n"
                for line in contents.splitlines()
            ).encode()).hex()
            sql_set = ", ".join(f"{k}='{v}'" if v is not None else f"{k}=NULL" for k, v in
                                dict(encrypted_username_1=new_encrypted_username_1,
                                     encrypted_username_2=new_encrypted_username_2,
                                     encrypted_contents=new_encrypted_contents).items())
            sql_where = " AND ".join(f"{k}='{v}'" if v is not None else f"{k} IS NULL" for k, v in
                                     dict(encrypted_username_1=encrypted_username_1,
                                          encrypted_username_2=encrypted_username_2,
                                          encrypted_contents=encrypted_contents).items())
            db.execute(f"UPDATE encrypted_chats SET {sql_set} WHERE {sql_where}")

    db.commit()
    if session["username"] == username:
        if new_username != username:
            session["username"] = new_username
        if new_admin != admin:
            session["admin"] = new_admin

    return "User modified. Back to <a href='/'>home</a>."


if __name__ == "__main__":
    app.secret_key = os.urandom(16)
    app.config.update(SESSION_COOKIE_HTTPONLY=False)
    app.run(host=HOST, port=PORT, threaded=False)
